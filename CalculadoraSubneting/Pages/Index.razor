@page "/"
@using System.Text.RegularExpressions;

<PageTitle>Calculadora</PageTitle>


<input @bind="VLSM" type="checkbox" />Calculadora VLSM

<table class="tabla1">
	<tr>
		<td>Dirección Ip/Máscara de red</td>
		<td><input @bind="ip" type="text"></td>
	</tr>
	<tr>
		<td>Número de subredes</td>
		<td>
				<input @bind="subredes">
				<button @onclick="Actualiza">Change</button>
		</td>
	</tr>
	<tr>
		<td>Tamaño de hosts</td>
		<td>
			@for (int i = 0; i < listaSubredes.Count; i++)
			{
				Subred subred = listaSubredes[i];
							<label>Nombre</label>
							<input @bind="subred.Nombre"  id="inputName" />

							<label>Tamaño</label>

								<input @bind="subred.Tamano" id="inputSize" />
							<br>
			}

		</td>
	</tr>
	<tr>
		<td class="submit" colspan="2">
			@if (!VLSM)
			{
						<button @onclick="Calcular">Enviar</button>
			}
			else
			{
						<button @onclick="Calcular">Enviar VLSM</button>
			}
		</td>
	</tr>
</table>
@if (posible && tamanoPosible)
{
	@if (calculado)
	{
			<table class="tabla2">
				<thead>
					<tr>
						<th>Nombre</th>
						<th>Dirección de subred</th>
						<th>Máscara de subred</th>
						<th>Rango de direcciones IP asignables</th>
						<th>Cantidad de hosts disponibles</th>
						<th>Dirección de broadcast</th>
					</tr>
				</thead>
				<tbody>

				@for (int i = 0; i < redesResult.Length; i++)
				{
												<tr>
													<td>@nombresResult[i]</td>
													<td>@redesResult[i]</td>
													<td>@mascaraResult</td>
													<td>@rangosResult[i]</td>
													<td>@hostsResult</td>
													<td>@broadcastResult[i]</td>
												</tr>
				}



					</tbody>

				</table>
	}
}
else
{
			<h1 class="error">Introduce una dirección Ip o un tamaño válido</h1>
}


@code {
	private List<Subred> listaSubredes = new List<Subred>();
	public string ip;
	public int subredes;
	public bool posible = true;
	public bool tamanoPosible = true;
	public bool VLSM;
	public bool calculado;
	public string[] listaNombres;
	public string[] listaTamanos;
	const int MASCARA_MAX = 32;
	const int TAMANO_BYTE = 8;
	const int DECIMAL_BYTE = 255;

	//variables para la tabla de resultados
	public string[] nombresResult;
	public string[] redesResult;
	public string[] rangosResult;
	public string[] broadcastResult;
	public string hostsResult;
	public string mascaraResult;

	private class Subred
	{
		public string Nombre { get; set; }
		public int Tamano { get; set; }
	}

	public bool Comprobar()
	{
		string tresCifras = @"(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
		string dosCifras = @"(?:[1-9]|[12]\d|3[012])$";
		string filtroRed = $@"\b{tresCifras}\.{tresCifras}\.{tresCifras}\.{tresCifras}\/{dosCifras}";
		Regex red = new Regex(filtroRed);//filtro red con su mascara

		return red.IsMatch(ip);
	}
	public void Calcular()
	{
		if (Comprobar())
		{
			posible = true;
			//Esto comprueba nº de hosts y bits necesarios segun las subredes
			int subRedesNecesarias = 1;
			int bitsNecesarios = 0;
			while (subRedesNecesarias < subredes)
			{
				subRedesNecesarias *= 2;
				bitsNecesarios++;
			}
			//int tamanoMaximo = (DECIMAL_BYTE + 1) / subRedesNecesarias;
			//tamanoPosible = listaSubredes.Max(x => x.Tamano) <= tamanoMaximo - 2; //el bool de si es posible o no guarda v si el tamaño k el pasa es <= que el necesario

			//Aqui separamos la mascara de la ip normal
			string[] a = ip.Split('/');
			int mascara = int.Parse(a[1]);
			string ipSinMascara = a[0];

			mascara += bitsNecesarios;

			string[] octetos = ipSinMascara.Split('.');
			string[] octetosBinarios = new string[4];
			for (int i = 0; i < octetos.Length; i++)
			{
				int octetoDecimal = int.Parse(octetos[i]);

				octetosBinarios[i] = PasarABinario(octetoDecimal).PadLeft(TAMANO_BYTE, '0');//esto rellena de 0 a la izquierda
			}

			string octetosBinariosJuntos = string.Empty;
			foreach (string octeto in octetosBinarios)//junta cada octeto a un solo string
			{
				octetosBinariosJuntos += octeto;
			}
			int numeroBitsHosts = MASCARA_MAX - mascara;//coge los bits que tenemos para hosts

			int totalHosts = int.Parse(Math.Pow(2, numeroBitsHosts + bitsNecesarios).ToString());//PasarADecimal(bitsParaHosts)+1 ;// comprobar si hay que sumar uno ya que no es lo mismo 2^8 que 8bits lleno de 1 a decimal

			int hostsCadaSubred = totalHosts / subRedesNecesarias;//host por cada subres
			tamanoPosible = listaSubredes.Max(x => x.Tamano) <= hostsCadaSubred -2 && hostsCadaSubred -2 >= 1; //el bool de si es posible o no guarda v si el tamaño k el pasa es <= que el necesario

			string[] ipesBinario = new string[subRedesNecesarias + 1];
			for (int i = 0; i < ipesBinario.Length; i++)
			{
				//Esto mete en ipes todos los numeros juntos(mascara y numero de hosts)
				ipesBinario[i] = octetosBinariosJuntos.Substring(0, mascara - bitsNecesarios) + PasarABinario(hostsCadaSubred * i - 1).PadLeft(numeroBitsHosts + bitsNecesarios, '0');

			}

			string[] ipesDecimal = new string[subRedesNecesarias + 1];//se guardaran las  ips en decimal
			for (int i = 0; i < ipesDecimal.Length; i++)
			{
				for (int j = 0; j < MASCARA_MAX; j += TAMANO_BYTE)
				{
					ipesDecimal[i] += PasarADecimal(ipesBinario[i].Substring(j, TAMANO_BYTE)).ToString() + '.';//te pasa a decimal cada 8 te pone un .

				}
				ipesDecimal[i] = ipesDecimal[i].Substring(0, ipesDecimal[i].Length - 1);//te quita el punto del final
			}

			GuardarDatos(mascara, ipesDecimal, hostsCadaSubred, subRedesNecesarias);
		}
		else
		{
			posible = false;// si no cumple las condiciones(para mostrar mensaje de fallo)
		}


	}

	private void Actualiza()
	{
		if (subredes >= listaSubredes.Count)//actualiza si le das un tamaño mas grande del que ya hay(de inputs)
		{
			for (int i = listaSubredes.Count; i < subredes; i++)
			{
				listaSubredes.Add(new Subred { Nombre = "" });
			}
		}
		else
		{
			for (int i = subredes - 1; i < listaSubredes.Count; i++)//actualiza si le das un tamaño mas pequeño del que ya hay(de inputs)
			{
				listaSubredes.Remove(listaSubredes[i]);
			}
		}
	}
	public void CalcularVLSM()
	{
		if (Comprobar())
		{
			posible = true;
			string[] a = ip.Split('/');
			int mascara = int.Parse(a[1]);
			string ipSinMascara = a[0];

			string[] octetos = ipSinMascara.Split('.');
			string[] octetosBinarios = new string[4];



		}
		else
		{
			posible = false;
		}


	}


	public void GuardarDatos(int mascara, string[] ipesDecimal, int hosts, int subredes)
	{
		mascaraResult = "/" + mascara.ToString();
		hostsResult = (hosts - 2).ToString();

		string[] redes = new string[subredes];//creamos arrays con un tamaño
		string[] broadcast = new string[subredes];
		string[] rango = new string[subredes];
		string[] nombres = new string[subredes];
		for (int i = 0; i < subredes; i++)
		{
			if (i == 0)
			{
				redes[i] = ipesDecimal[i];//el primero ya que es la 00
			}
			else
			{
				redes[i] = Suma1(ipesDecimal[i]);
			}

			rango[i] = Suma1(redes[i]) + " - " + Resta1(ipesDecimal[i + 1]);

			broadcast[i] = ipesDecimal[i + 1];

			if (i >= listaSubredes.Count)
			{
				nombres[i] = "Red Libre";
			}
			else
			{
				nombres[i] = listaSubredes[i].Nombre;
			}

			//nombresResult[i] = listaSubredes[i].Nombre ?? "Red Libre";

			Console.WriteLine(redes[i] + "//" + rango[i] + "//" + broadcast[i]);
		}
		nombresResult = nombres;
		redesResult = redes;
		broadcastResult = broadcast;
		rangosResult = rango;

		calculado = true;

	}

	public string Suma1(string ip)//separa octetos y al ultimo le suma uno
	{
		string[] octetos = ip.Split('.');
		octetos[3] = (int.Parse(octetos[3]) + 1).ToString();
		for (int i = octetos.Length - 1; i > 0; i--)
		{
			if (octetos[i] == "256")
			{
				octetos[i] = "0";
				octetos[i - 1] = (int.Parse(octetos[i - 1]) + 1).ToString();
			}
		}



		return string.Join('.', octetos);
	}

	public string Resta1(string ip)//separa octetos y al ultimo le resta uno
	{
		string[] octetos = ip.Split('.');
		octetos[3] = (int.Parse(octetos[3]) - 1).ToString();
		for (int i = octetos.Length - 1; i > 0; i--)
		{
			if (octetos[i] == "-1")
			{
				octetos[i] = "255";
				octetos[i - 1] = (int.Parse(octetos[i - 1]) - 1).ToString();
			}
		}
		return string.Join('.', octetos);
	}



	public int PasarADecimal(string numeroBinario)
	{
		int decimalNumber = 0;//numero empieza en 0

		for (int i = 0; i < numeroBinario.Length; i++)//recorre numero binario
		{
			decimalNumber += int.Parse(numeroBinario[i].ToString()) * (int)Math.Pow(2, numeroBinario.Length - i - 1);//cada binario lo multiplica por su valor
		}
		return decimalNumber;
	}

	public string PasarABinario(int numero)
	{
		string numeroBinario = ""; // cadena vacía para almacenar el número binario

		while (numero > 0) // mientras el número decimal sea mayor que cero
		{
			int resto = numero % 2; // calcula el resto de la división por 2
			numeroBinario = resto.ToString() + numeroBinario; // agrega el dígito al número binario
			numero /= 2; // divide el número decimal entre 2
		}
		return numeroBinario;
	}
}